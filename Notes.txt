1. the new sending and recving mechanism works as follows:

server_v3 has 3 sockets:
socket_listen to send the data to all the client terminal units
socket_listen2 to send the data to all the client terminal units
recver is to recv data from the client terminal units

sending data has two threads as follows:
1. to send the data to the client terminal units.
2. to send the data to the client display unit.
3. to recv the data we are using the same thread as that of game loop

this way we are ensuring that data reaches to all the clients at the appropriate time...
-----------------------------------------------------------------------------------------------------------------
the new alogirthm used to remove the packet loss:
persistence of information:
how i designed the entire network protocol for the game:
1. threading for recving and sending the data
2. fragmenting packets to suit the size of MTU
3. persistence of information so that no important information is missed.

persistence of information increases the size of the packet that is being transmitted but makes sure that no packet carrying important information
is lost; uses a simple mechanism of ack, send for some time so that the client can delete it over the time
-----------------------------------------------------------------------------------------------
for making the game support for multiple languages: we need to follow the following architecture:
-----------------------------------------------------------------------------------------------

The power behing AI_PLAYGROUNDS and programming games:

Greed can be used as a proxy to code the AI agent for realtime warfare.
Greed has approximately 1*10^25 states, solving such a huge number of states is a challenging task;
but we can use the following approach to solve the problem:

it will become the worlds toughest competitions in the world. the competition will code for the AI agent to win!
atleast let it reach the level of robocode and other games, let atleast 1k people play the game

---------------------------------------------------------------------
things i want someone else to do while i am coding:

1. maintain the online presence of the game

2. hangle the marketing.

3. talk to the potential customers'
here the custormers are college clubs and societies

someone to keep on thinking about the company when i am busy in coding. someone who will keep on managing the website work and the marketing work
----------------------------------------------------------------------------------------------------------------
---------------------------RESTARTING THE GAME SERVER MECHANISM------------------------------------------------

the main problem was in closing the threads safely, namely send_data_terminal, send_data_display , recv_data and nav_process.
in server_v3 file.
due to lately closing of these threads they were hindering in re-binding the sockets, because they were keep on using it even after getting it closed.

following mechanisms are used to close the threads:

1. for send_data_terminal, recv_data, and nav_process.

making a proxy variable like gameOver_temp, which will have the value of gameOVer, so when the game is really over, these functions will read the proxy value
and update them at their own leisure, when they encounter that the values have been updated they just return.
for this we also need to come out from the waiting cond variable.

2. for send_data_display:
we could've used the previous method for closing the thread, but it was not sending the game over message to the display unit, because it was closing
before sending the value. so we are just checking if any message contains any ending message if yes then it will turn a flag on, and after sending that
value to all the display units we can safely return from the function.

potential bug: not all client display units may recv the game OVer message,we need to check if all of them have that message.
for this we can solve this by ensuring that we are sending the message mutiple times.
-------------------------------------------------------------------------------------------------------------------------------------------
----------------------------REMEBERING the GAME SESSION AGAINST SAME USERID AND PASSWORD TWICE---------------------------------------------

So I did it, the lobby server will remeber who are logged in, by a simple mechanism called heartbeat, it will check who all are logged in by recving a heartbeat
from the clients, and maintains a list of logged in usernames. its just that simple, i got it checked with the VM its working fine for now.

------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------- UNABLE TO HANDLE WHEN A PLAYER CLOSES WHILE HANDSHAKING---------------------------------------------

the handshake mechanism is too complex too touch, it will be done, when something fucking happens that's all, i know that it is a bug.

------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------THE PROBLEM OF LATE RESPONSE IN MOTION OF THE SHIP----------------------------------------
issue: whenever setPath is called by the client, it takes atmost 5 cycles of algorithmic cycles to reflect in motion, the time is due to A* implementation
just write in the docs that to check if the ship is in motion just after calling any navigation function is not the best method, to check if the command
succeeded or not, the best way is to check if the command returned true or false, if it returned true, then it will happen, no need to take tension in that

So I solved this problem
turn on the motion and navigation_promise, if the conditions satisfy for the motion. don;t listen to server's motion until the navigation_promise is true
make it false by checking if ship's absolute position changed, if yes then make navigation_promise to false, after this the client will listen to the
server's motion state

sail function is depricated due to its incompetancy.....

----------------------------------------------------------------------------------------------------------------------------------------
------------------------------MODIFIED THE FUNCTIONS OF CHASE SHIP FUNCTION--------------------------------
it will break in the following conditions:
1. target of the ship died.
2. the ship collides with something, (probably other ship)
3. game is over

you can call the chaseShip function only when you are not in the radius of the target ship, chaseSHip is used to get near the target ship if you 
are already in the radius of the ship it won't be called.

But assume that you had called the function but you stopped when you reached your target(the location of the ship) the chaseShip function will continue to
function untill the following events happen
1. target dies
2. your ship collides with something.
-----------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------SCHEMA OF DATABASE-------------------------------------------------------------------

Schema of the userdata:

ID ( INT ) ( primarky key)
username (string) (unique)
password(string)
country(string)
designation (string)
email (string) (has to be derived from sign up using Oauth)

Schema of rankings (both tournaments and normal ranked matches)

ID (int) (foreign key)
Total_Matches (int)
T_ID (string) tournament ID 
Total_score(int)

Logs of the total games played:

ID (int) foreign key
 
Date (date format with time) //

Type (string) (RANKED, UNRANKED, T_ID)







-------------------temp
conditions for setPath(coords)

target.r != -1 && temp[i][0].target.c != -1


b.tile_id != Entity::CANNON && graph[goal.r * columns + goal.c].b.tile_id != Entity::LAND


for setPath(ship id)

temp[i][0].s_id != -1 && pl1[temp[i][0].s_id]->getDiedStatus() == 0

for sailing
temp[i][0].type == 1 && temp[i][0].n > 0 && temp[i][0].dir != Direction::NA
(d != Direction::NA && tiles >= 1)

for chasing a ship:

temp[i][0].s_id >= 0 && pl1[temp[i][0].s_id]->getDiedStatus()==0
autopilot == 0 //protected by mchase mutex

for anchor ship
motion should be 0;











